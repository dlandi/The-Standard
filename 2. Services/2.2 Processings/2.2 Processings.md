# 2.2 Processing Services (Higher-Order Business Logic)

## 2.2.0 Introduction

A Processing service is a layer that implements a higher order of business logic. It may combine (or orchestrate) two primitive-level functions from their corresponding foundation service to introduce a newer functionality. They may also call one primitive function and change the outcome with a little bit of added business logic. And sometimes, processing services are there as a pass-through to introduce balance to the overall architecture.

Processing services are optional, depending on your business need. In a simple CRUD operations API, processing services will cease to exist beyond that point as there is no need for a higher order of business logic.

Here's an example of what a Processing service function would look like:

```csharp
public ValueTask<Student> UpsertStudentAsync(Student student) =>
TryCatch(async () =>
{
    ValidateStudent(student);

    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    bool studentExists = allStudents.Any(retrievedStudent =>
        retrievedStudent.Id == student.Id);

    return studentExists switch {
        false => await this.studentService.RegisterStudentAsync(student),
        _ => await this.studentService.ModifyStudentAsync(student.Id)
    };
});
```

Foundation services are a layer of validation on the existing primitive operations, which means that Processing services functions are beyond primitive, and they only deal with local models, as we will discuss in the upcoming sections.

## 2.2.1 On The Map

When used, Processing services live between foundation services and the rest of the application. They may not call Entity or Business brokers, but they may call Utility brokers such as logging brokers, time brokers, and any other brokers that offer supporting functionality and are not specific to any particular business logic. Here's a visual of where Processing services are located on the map of our architecture:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/111928442-d9cd1b00-8a70-11eb-82c8-83399c98c87d.png" />
    </p>
<br />

On the right side of a Processing service lies all the non-local models and functionality, whether through the brokers or the models the foundation service is trying to map into local models.

On the left side of Processing, services are pure local functionality, models, and architecture, and there should be no trace or track of any native or non-local models in the system.

## 2.2.2 Characteristics

Processing services, in general, are combiners of multiple primitive-level functions to produce a higher-order business logic. But they have more characteristics than just that. Let's talk about those here.

### 2.2.2.0 Language

The language used in Processing services defines the complexity level and its capabilities. Usually, Processing services combine two or more primitive operations from the foundation layer to create a new value.

#### 2.2.2.0.0 Functions Language

At a glance, Processing services language change from primitive operations such as `AddStudent` or `RemoveStudent` to `EnsureStudentExists` or `UpsertStudent`. they usually offer more advanced business-logic operations to support a higher order functionality.

Here are some examples of the most common combinations a processing service may offer:

| Processing Operation     | Primitive Functions                                        |
| ------------------------ | ---------------------------------------------------------- |
| EnsureStudentExistsAsync | RetrieveAllStudents + AddStudentAsync                      |
| UpsertStudentAsync       | RetrieveStudentById + AddStudentAsync + ModifyStudentAsync |
| VerifyStudentExists      | RetrieveAllStudents                                        |
| TryRemoveStudentAsync    | RetrieveStudentById + RemoveStudentByIdAsync               |

As you can see, the combination of primitive functions, Processing services might also include an additional layer of logic on top of the existing primitive operation. For instance, `VerifyStudentExists` takes advantage of the `RetrieveAllStudents` primitive function, and then adds a boolean logic to verify the returned student by and Id from a query that actually exists or not before returning a `boolean`.

#### 2.2.2.0.1 Pass-Through

Processing services may borrow some of the terminology from foundation services; for instance, in a pass-through scenario, a processing service may be as simple as `AddStudentAsync`. We will discuss the architecture-balancing scenarios later in this chapter.
Unlike Foundation services, Processing services must have the identifier `Processing` in their names. For instance, we say `StudentProcessingService`.

#### 2.2.2.0.2 Class-Level Language

More importantly, Processing services must include the name of the entity supported by their corresponding Foundation service.
For instance, if a Processing service depends on a `TeacherService`, the service name must be `TeacherProcessingService`.

### 2.2.2.1 Dependencies

Processing services can only have two types of correlated dependencies:  Foundation service or a Utility broker. Processing services are nothing but an extra higher-order level of business logic orchestrated by combined primitive operations on the Foundation level. Processing services can also use Utility brokers such as `TimeBroker` or `LoggingBroker`. But it shall never interact with an Entity or Business broker.

### 2.2.2.2 One-Foundation

Processing services can interact with one and only one Foundation service. In fact, without a foundation service, there can never be a Processing layer. And just like we mentioned above about the language and naming, Processing services take on the same entity name as their Foundation dependency. For instance, a processing service that handles higher-order business logic for students will communicate solely with its foundation layer, which would be `StudentService`. That means that processing services will have one and only one service as a dependency in its construction or initiation as follows:

```csharp
public class StudentProcessingService
{
    private readonly IStudentService studentService;

    public StudentProcessingService(IStudentService studentService) =>
        this.studentService = studentService;
}
```

However, processing services may require dependencies on multiple utility brokers such as `DateTimeBroker` or `LoggingBroker` ... etc.

### 2.2.2.3 Used-Data-Only Validations

Unlike the Foundation layer services, Processing services only validate what it needs from its input. For instance, if a Processing service is required to validate if a student entity exists, and its input model is an entire `Student` entity, it will only validate that the entity is not `null` and that the `Id` of that entity is valid. The rest of the entity is not the concern of the Processing service.
Processing services delegate full validations to the layer of services that is concerned with that which is the Foundation layer. Here's an example:

```csharp
public ValueTask<Student> UpsertStudentAsync(Student student) =>
TryCatch(async () =>
{
    ValidateStudent(student);

    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    bool isStudentExists = allStudents.Any(retrievedStudent =>
        retrievedStudent.Id == student.Id);

    return isStudentExsits switch {
        false => await this.studentService.RegisterStudentAsync(student),
        _ => await this.studentService.ModifyStudentAsync(student.Id)
    };
});
```

Processing services are also not very concerned about outgoing validations except for what it needs within the same routine. For instance, if a Processing service is retrieving a model to be passed to another primitive-level function on the Foundation layer, the Processing service will be required to validate that the retrieved model is valid depending on which attributes of the model it uses.
For Pass-through scenarios, however, processing services will delegate the outgoing validation to the foundation layer.

## 2.2.3 Responsibilities

Processing services' primary responsibility is to provide higher-order business logic, which happens along with the usual signature mapping and various use-only validations, which we will discuss in detail in this section.

### 2.2.3.0 Higher-Order Logic

Higher-order business logic is functions that are above primitive. For instance, `AddStudentAsync` function is a primitive function that does one thing and one thing only. Higher-order logic changes the outcome of a single primitive function like `VerifyStudentExists`, which returns a boolean value instead of the entire object of the `Student`. Another example: a combination of multiple primitive functions such as `EnsureStudentExistsAsync`, which is a function that will only add a given `Student` model if and only if the object mentioned above doesn't already exist in storage. Here are some examples:

#### 2.2.3.0.0 Shifters

The shifter pattern in a higher order business logic is when the outcome of a particular primitive function changes from one value to another (Ideally, a primitive type such as a `bool` or `int` and not a completely different type as that would violate the purity principle.)
For instance, in a shifter pattern, we want to verify if a student exists or not. We don't want the entire object, but just whether it exists in a particular system or not. Now, this seems like a case where we only need to interact with one and only one foundation service, and we are shifting the value of the outcome to something else, which should fit perfectly in the realm of the processing services. Here's an example:

```csharp
public ValueTask<bool> VerifyStudentExists(Guid studentId) =>
TryCatch(async () =>
{
    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    ValidateStudents(allStudents);

    return allStudents.Any(student => student.Id == studentId);
});
```

In the snippet above, we provided a higher order business logic by returning a boolean value of whether a particular student with a given `Id` exists in the system or not. There are cases where your orchestration layer of services isn't really concerned with all the details of a particular entity but just knowing whether it exists or not as a part of higher business logic or what we call orchestration.

Here's another popular example of the Processing Services shifting pattern:

```csharp
public int RetrieveStudentsCount() =>
TryCatch(() =>
{
    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    ValidateStudents(allStudents);

    return allStudents.Count();
});
```

In the example above, we provided a function to retrieve the count of all students in a given system. It's up to the system's designers to determine whether to interpret a `null` value retrieved for all students as an unexpected exception case or return a `0`; all depending on how they manage the outcome.
In our case here, we validate the outgoing data as much as the incoming, especially if it's going to be used within the processing function to ensure further failures do not occur for upstream services.

#### 2.2.3.0.1 Combinations

Combining multiple primitive functions from the foundation layer to achieve a higher-order business logic is one of the main responsibilities of a Processing Service. As we mentioned before, some of the most popular examples is for ensuring a particular student model exists as follows:

```csharp
public async ValueTask<Student> EnsureStudentExistsAsync(Student student) =>
TryCatch(async () =>
{
    ValidateStudent(student);

    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    Student maybeStudent = allStudents.FirstOrDefault(retrievedStudent =>
        retrievedStudent.Id == student.Id);

    return maybeStudent switch
    {
        {} => maybeStudent,
        _ => await this.studentService.AddStudentAsync(student)
    };
});
```

In the code snippet above, we combined `RetrieveAll` with `AddAsync` to achieve a higher-order business logic operation. The `EnsureAsync` operation must verify that an entity exists before trying to persist it. The terminology around these higher-order business logic routines is essential to control the expectations of the outcome and the inner functionality. It also ensures that fewer cognitive resources from the engineers are required to understand the underlying capabilities of a particular routine.
The conventional language used in these services also guards against duplicated logic. For instance, an engineering team not writing to a standard might create `TryAddStudentAsync` while already having an existing functionality such as `EnsureStudentExistsAsync`, which does the same thing. The convention here with the limitation of the size of capabilities a particular service may have ensures redundant work shall never occur on any occasion.
Many combinations can produce a higher-order business logic; for instance, we may need to implement a functionality that ensures the removal of a student. We use `EnsureStudentRemovedByIdAsync` to combine a `RetrieveById` and a `RemoveById` in the same routine. It all depends on what level of capabilities an upstream service may need to implement such a functionality.

### 2.2.3.1 Signature Mapping

Although processing services operate entirely on local models and contracts, they are still required to map foundation-level services' models to their local models. For instance, if a foundation service is throwing `StudentValidationException` then processing services will map that exception to `StudentProcessingDependencyValidationException`. Let's talk about mapping in this section.

#### 2.2.3.1.0 Non-Exception Local Models

In general, processing services are required to map any incoming or outgoing objects with a specific model to its own. But that rule doesn't always apply to non-exception models. For instance, if a `StudentProcessingService` is operating based on a `Student` model, and there's no need for a special model for this service, then the processing service may be permitted to use the same model from the foundation layer.

#### 2.2.3.1.1 Exception Models

Regarding processing services handling exceptions from the foundation layer, it is essential to understand that exceptions in our Standard are more expressive in their naming conventions and role than other models. Exceptions here define the what, where, and why they are thrown every time.

For instance, an exception called `StudentProcessingServiceException` indicates the exception entity, the `Student` entity; the location of the exception, which is the `StudentProcessingService`; and lastly, the reason for that exception which is `ServiceException` indicating an internal error to the service that is not a validation or a dependency of nature that happened.
Just like the foundation layer, Processing services will do the following mapping to occurring exceptions from its dependencies:

| Exception                            | Wrap Inner Exception With | Wrap With                                      | Log Level |
| ------------------------------------ | ------------------------- | ---------------------------------------------- | --------- |
| StudentDependencyValidationException | Any inner exception       | StudentProcessingDependencyValidationException | Error     |
| StudentValidationException           | Any inner exception       | StudentProcessingDependencyValidationException | Error     |
| StudentDependencyException           | -                         | StudentProcessingDependencyException           | Error     |
| StudentServiceException              | \_                        | StudentProcessingDependencyException           | Error     |
| Exception                            | \_                        | StudentProcessingServiceException              | Error     |

[*] [Processing services in Action (Part 1)](https://www.youtube.com/watch?v=VgzoZ-b1A4U)

[*] [Processing services in Action (Part 2)](https://www.youtube.com/watch?v=4lfZcWzbIcE)

[*] [Processing services in Action (Part 3)](https://www.youtube.com/watch?v=R4sA4V4-_5o)

[*] [Processing services in Action (Part 4)](https://www.youtube.com/watch?v=u4uqBiB1TaI)
